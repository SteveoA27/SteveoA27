Overview

These scripts demonstrate various operations (e.g., arithmetic evaluation, user login) but contain significant 
vulnerabilities due to improper handling of user inputs and reliance on unsafe functions like eval(). These issues 
can be exploited to execute arbitrary code or inject malicious payloads, leading to potential system compromises.

Contents
example.py
hack1.py
hack2.py
hack3.py
hack1.txt
hack2.txt
hack3.txt
vulnerability.py


Key Components

1. example.py
  Purpose: Reads input from a file or console and executes the provided code using eval().
  Vulnerability: Directly executes user input through eval().
  I t will be executed if example.txt contains malicious input (e.g., os.system('rm -rf /')).
  Exploit Example: Writing hack() in example.txt triggers the predefined hack function in vulnerability.py.

2. hack1.py
  Purpose: Evaluate arithmetic expressions read from a file (hack1.txt) or user input.
  Vulnerability: Uses eval() to process user-provided expressions without validation.
  If hack1.txt contains malicious input, such as hack(), it triggers the hack function in vulnerability.py.
  Exploit Example: The input hack() # + "" ensures hack() is executed while bypassing input validation attempts.

  hack1.txt contains the payload hack()# + "".

  The script concatenates and directly evaluates the input using eval(" ".join(user_sum)).
  The eval() function processes hack() and calls it as defined in vulnerability.py.

  The hack() function executes, producing the string "Oh no! I have been hacked!".

3. hack2.py
  Purpose: Reads a number from a file (hack2.txt) or console and adds 1 to it.
  Vulnerability: Uses eval() to process input.

  hack2.txt 

  The eval() function in hack2.py evaluates the input directly as Python code.
  Since hack() is a valid function in vulnerability.py, it gets executed, returning "Oh no! I have been hacked!".

  The script's intended functionality of adding 1 to a numeric input is entirely bypassed because the payload executes hack() instead.
  The # ensures no errors occur, even if additional operations were expected.

4. hack3.py
  Purpose: Simulates a login function by checking usernames against a predefined list.
  Vulnerability: Uses eval() to execute user input concatenated with the login function.
  Input like ') + hack() # manipulates the function call to execute the hack function.
  Exploit Example: Writing ') + hack() # in hack3.txt injects the hack function call.

  The hack file hack3.txt contains ')+ hack() #.
  The eval() function executes the dynamically created string.
  When user_input is replaced with ')+ hack() #
  login('') evaluates to an empty string ("") because the username is not in the user's list.
  hack() is executed, returning "Oh no! I have been hacked!". The + operator concatenates the results, 
  resulting in "Oh no! I have been hacked!".
  
5. vulnerability.py
  Purpose: Contains a simple function hack() that returns a predefined message from one of the previous .py files.
  Injection via Files: Inputs are often read from files (example.txt, hack1.txt, etc.) that can be manipulated to contain malicious payloads.
  Injection via Console Input: The scripts prompt for user inputs that are directly passed to eval().

No additional downloads are required. Use VScode in the Python language

Run the code through the .py files that will call to their respective txt files. 

Created and edited by myself Stephen 

